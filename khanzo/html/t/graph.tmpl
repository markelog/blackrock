<div style="width:100%;">
  <canvas id="canvas"></canvas>
</div>
<hr>
<div style="width:100%;">
  <canvas id="canvas-uniq"></canvas>
</div>
<hr>
<div style="width:100%;">
  <canvas id="canvas-avg"></canvas>
</div>

<script>
var time_bucket = {{ .Chart.TimeBucket }};
var time_start = {{ .Chart.TimeStart }};
var time_end = {{ .Chart.TimeEnd }};

var data = JSON.parse('{{ json .Chart.PerTimePerType }}'); // faster than AST parsing

let options = function (k) {
  return {
    legend: {
      position: 'left',
    },
    responsive: true,
    title: {
      display: true,
      text: k,
    },
    tooltips: {
      mode: 'index',
      intersect: false,
    },
    hover: {
      mode: 'nearest',
      intersect: true
    },
    scales: {
      xAxes: [{
        display: true,
      }],
      yAxes: [{
        display: true,
      }]
    }  
  }
}

let countConfig = {
  type: 'line',
  data: {
    labels: [],
    __labels: {},
    datasets: [],
    __datasets: {}
  },
  options: options("total count")
}

let countUniqueConfig = {
  type: 'line',
  data: {
    labels: [],
    __labels: {},
    datasets: [],
    __datasets: {}

  },
  options: options("count per unique user")
}

let countAvgConfig = {
  type: 'line',
  data: {
    labels: [],
    __labels: {},
    datasets: [],
    __datasets: {}
  },
  options: options("avg count per userr")
}

var dateOptions = { weekday: 'short', year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', hour: 'numeric', minute: 'numeric'  };
function stringToColour(input) {
  return randomColor({
    hue: 'blue',
    seed: input,
    format: 'rgba',
    alpha: 0.5
  });
}

var add = function(where,bucket, count, k, orig) {
  let label = new Date(bucket * 1000).toLocaleDateString("en-GB", dateOptions)
  let l = where.__labels[bucket]
  if (!l) {
    where.labels.push(label)
    where.__labels[bucket] = true
  }
  
  s = where.__datasets[k]
  if (!s) {
    s = {
      label: k,
      data: [],
      fill: false,
      backgroundColor: stringToColour(orig),
      borderColor: stringToColour(orig),
    }
    where.datasets.push(s)
    where.__datasets[k] = s
  }
  s.data.push(count)
}

let thresh = 5;
let topFilter = {}
{
  let topKeys = {}
  for (let bucket in data) {
    for (let k in data[bucket]) {
      let d = data[bucket][k]
      topKeys[d.event_type] = (topKeys[d.event_type]  || 0) + d.count_unique
    }
  }

  let topSorted = Object.keys(topKeys)
  topSorted.sort((a,b) => topKeys[b] - topKeys[a])

  let j = 0
  for (let x of topSorted) {
    topFilter[x] = true
    j++
    if (j >= thresh)
      break;
  }
}

for (let b = time_start - time_bucket; b <= time_end; b += time_bucket) {
  let perBucket = (data[b] || {})
  for (k in topFilter) {
    let value = perBucket[k] || { event_type: k, count: 0, count_unique: 0, bucket: b}

    add(countConfig.data, value.bucket, value.count, value.event_type, value.event_type)
    add(countUniqueConfig.data, value.bucket, value.count_unique, value.event_type + '_uniq', value.event_type)
    add(countAvgConfig.data, value.bucket, value.count_unique == 0 ? 0 : value.count / value.count_unique, value.event_type + '_avg', value.event_type)
  }
}


window.countConfig = new Chart(document.getElementById('canvas').getContext('2d'), countConfig);
window.countUniqConfig = new Chart(document.getElementById('canvas-uniq').getContext('2d'), countUniqueConfig);
window.countAvgConfig = new Chart(document.getElementById('canvas-avg').getContext('2d'), countAvgConfig);

</script>